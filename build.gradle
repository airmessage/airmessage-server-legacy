plugins {
    id "java"
    id "application"
}

group "me.tagavari"
version "3.2.1"

repositories {
    mavenCentral()
}

dependencies {
    //SQLite JDBC - Database library
    implementation "org.xerial:sqlite-jdbc:3.36.0"

    //jOOQ - Database library
    implementation "org.jooq:jooq:3.14.11"

    //Sentry - Crash reporting library
    implementation "io.sentry:sentry:5.0.1"

    //SLF4J - Logging library
    //implementation "org.slf4j:slf4j-nop:1.7.30"

    //Jackson YAML data format - YAML parser
    implementation "com.fasterxml.jackson.dataformat:jackson-dataformat-yaml:2.12.3"

    //Commonmark Java - Markdown parser
    implementation "org.commonmark:commonmark:0.17.2"

    //JavaWebsocket - WebSocket library
    implementation "org.java-websocket:Java-WebSocket:1.5.2"

    if(System.getProperty("os.arch") == "aarch64") {
        implementation fileTree("lib-applesilicon") { include "*.jar" }
    } else {
        implementation fileTree("lib-intel") { include "*.jar" }
    }
}

task installConnectAuth(type: Exec) {
    workingDir "connectauth"
    commandLine "npm", "install"
}

task buildConnectAuth(type: Exec) {
    dependsOn installConnectAuth
    workingDir "connectauth"
    commandLine "npm", "run", "build"
}

task copyToLib(type: Copy) {
    from configurations.default
    into jar.destinationDirectory.asFile.get()
}

/* task jlink(type: Exec) {
    final String jDeps = "java.base,java.desktop,java.logging,java.sql,java.xml,java.datatransfer,java.compiler,jdk.unsupported,java.naming,jdk.crypto.ec,jdk.httpserver"

    inputs.property("jlink.jdeps", jDeps)
    outputs.dir("${buildDir}/java-runtime")

    doFirst {
        delete "${buildDir}/java-runtime"
    }

    commandLine "${System.properties."java.home"}/bin/jlink",
            "--no-header-files",
            "--no-man-pages",
            "--strip-debug",
            "--compress=2",
            "--add-modules", jDeps,
            "--output", "${buildDir}/java-runtime"
} */

task jpackage(type: Exec) {
    dependsOn ordered("clean", "build", "copyToLib")

    final String jDeps = "java.base,java.desktop,java.logging,java.sql,java.xml,java.datatransfer,java.compiler,jdk.unsupported,java.naming,jdk.crypto.ec,jdk.httpserver"

    inputs.dir(jar.destinationDirectory.asFile.get())
    //inputs.dir("${buildDir}/java-runtime")
    outputs.dir("AirMessage.app")

    doFirst {
        delete "AirMessage.app"
    }

    commandLine "${System.properties."java.home"}/bin/jpackage",
            "--name", "AirMessage",
            "--app-version", version,
            "--input", jar.destinationDirectory.asFile.get(),
            "--main-jar", jar.archiveFileName.get(),
            "--main-class", "me.tagavari.airmessageserver.server.Main",
            "--type", "app-image",
            "--java-options", "-XstartOnFirstThread",
            "--add-modules", jDeps,
            "--mac-package-identifier", "me.tagavari.airmessageserver",
            "--mac-package-name", "AirMessage",
            "--mac-package-signing-prefix", "airmessage",
//            "--mac-sign",
//            "--mac-signing-key-user-name", "Mac Developer: Developer Name (DUCNFCN445)",
            "--icon", "AirMessage.icns"
}

task configurePlist(type: Exec) {
    mustRunAfter jpackage
    inputs.dir("AirMessage.app")
    outputs.file("AirMessage.app/Contents/Info.plist")

    commandLine "plutil", "-insert", "LSUIElement", "-string", "True", "AirMessage.app/Contents/Info.plist"

    doLast {
        exec {
            commandLine "plutil", "-insert", "NSAppTransportSecurity", "-xml", "<dict><key>NSAllowsLocalNetworking</key><true/><key>NSAllowsArbitraryLoads</key><true/></dict>", "AirMessage.app/Contents/Info.plist"
        }
    }
}

task publish {
    dependsOn ordered("jpackage", "configurePlist")
}

task buildAndRun(type: Exec) {
    dependsOn publish

    commandLine "AirMessage.app/Contents/MacOS/AirMessage"
}

application {
    mainClassName = "me.tagavari.airmessageserver.server.Main"
    applicationDefaultJvmArgs = ["-XstartOnFirstThread"]
}

run {
    args = ["-debug"]
}

def ordered(String... dependencyPaths) {
    def dependencies = dependencyPaths.collect{ tasks.getByPath(it) }
    for(int i = 0; i < dependencies.size() - 1; i++) {
        dependencies[i + 1].mustRunAfter(dependencies[i])
    }
    return dependencies
}

task printVersionName {
    doLast {
        println version
    }
}

task printJarName {
    doLast {
        println jar.archiveFileName.get()
    }
}